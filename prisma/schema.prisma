generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role { 
  learner 
  expert 
}

enum SlotState { 
  open 
  held 
  booked 
  blocked 
}

enum BookingStatus { 
  pending 
  awaiting_confirmation 
  confirmed 
  completed 
  cancelled 
  refunded 
  no_show 
}

enum PaymentStatus { 
  requires_capture 
  paid 
  refunded 
}

enum NotificationChannel { 
  email 
  in_app 
}

enum NotificationType { 
  BOOKING_AWAITING_CONFIRMATION 
  BOOKING_CONFIRMED_ICS 
  BOOKING_DECLINED 
  REMINDER_24H 
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  name            String?
  bio             String?   @db.Text
  avatarUrl       String?
  timeZone        String?   // e.g. "Europe/Copenhagen"
  locale          String?   // e.g. "da-DK"
  role            Role
  supabaseUserId  String    @unique
  deletedAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  expertProfile   ExpertProfile?
  learnerBookings Booking[]  @relation("LearnerBookings")
  expertBookings  Booking[]  @relation("ExpertUserBookings")
  reviews         Review[]   @relation("LearnerReviews")
  auditLogs       AuditLog[] @relation("AuditActor")
  notifications   Notification[]

  @@index([role, createdAt])
}

model ExpertProfile {
  id             String    @id @default(cuid())
  userId         String    @unique
  displayName    String?
  headline       String?
  description    String?   @db.Text
  tags           String[]  // simple array; use join table later if needed
  hourlyRate     Decimal   @db.Decimal(10, 2)
  currency       String    // ISO-4217
  isPublished    Boolean   @default(false)
  avgRating      Decimal?  @db.Decimal(3, 2)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  availability   AvailabilitySlot[]
  bookings       Booking[]
  reviews        Review[]

  @@index([isPublished, createdAt])
}

model AvailabilitySlot {
  id               String    @id @default(cuid())
  expertProfileId  String
  startAt          DateTime
  endAt            DateTime
  durationMinutes  Int
  state            SlotState @default(open)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  expertProfile    ExpertProfile   @relation(fields: [expertProfileId], references: [id], onDelete: Cascade)
  booking          Booking?

  @@index([expertProfileId, startAt])

  // NOTE: Enforce endAt > startAt in application logic or via a raw SQL CHECK in a separate migration.
}

model Booking {
  id               String    @id @default(cuid())
  learnerId        String
  expertProfileId  String
  expertUserId     String     // denormalized for faster joins; keep in sync with ExpertProfile.userId
  slotId           String     @unique
  status           BookingStatus
  // pricing snapshot
  amount           Decimal    @db.Decimal(10, 2)
  currency         String
  // display TZ snapshots
  learnerTimeZone  String?
  expertTimeZone   String?
  noteToExpert     String?    @db.Text
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  // Relations
  learner          User           @relation("LearnerBookings", fields: [learnerId], references: [id], onDelete: Restrict)
  expertUser       User           @relation("ExpertUserBookings", fields: [expertUserId], references: [id], onDelete: Restrict)
  expertProfile    ExpertProfile  @relation(fields: [expertProfileId], references: [id], onDelete: Restrict)
  slot             AvailabilitySlot @relation(fields: [slotId], references: [id], onDelete: Restrict)
  payment          Payment?
  session          Session?
  review           Review?
  notifications    Notification[]

  @@index([expertProfileId, createdAt])
  @@index([learnerId, createdAt])
}

model Payment {
  id                   String        @id @default(cuid())
  bookingId            String        @unique
  paymentIntentId      String        @unique
  paymentMethodId      String?
  captureOnAccept      Boolean       @default(true)
  status               PaymentStatus
  amount               Decimal       @db.Decimal(10, 2)
  currency             String
  refundedAmount       Decimal       @default(0) @db.Decimal(10, 2)
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt

  booking              Booking         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  notifications        Notification[]

  @@index([status, createdAt])
}

model Session {
  id                 String   @id @default(cuid())
  bookingId          String   @unique
  provider           String   // "zoom"
  meetingId          String?
  hostJoinUrl        String?
  participantJoinUrl String?
  password           String?
  scheduledStartAt   DateTime?
  scheduledEndAt     DateTime?
  actualStartAt      DateTime?
  actualEndAt        DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  booking            Booking         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  notifications      Notification[]
}

model Review {
  id               String   @id @default(cuid())
  bookingId        String   @unique
  expertProfileId  String
  learnerId        String
  rating           Int
  comment          String?  @db.Text
  isVisible        Boolean  @default(true)
  createdAt        DateTime @default(now())

  booking          Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  expertProfile    ExpertProfile @relation(fields: [expertProfileId], references: [id], onDelete: Restrict)
  learner          User          @relation("LearnerReviews", fields: [learnerId], references: [id], onDelete: Restrict)

  @@index([expertProfileId, createdAt])

  // NOTE: Enforce rating between 1..5 in application logic or via a raw SQL CHECK in a separate migration.
}

model Notification {
  id            String               @id @default(cuid())
  toUserId      String?
  type          NotificationType
  channel       NotificationChannel
  subject       String?
  payload       Json
  sentAt        DateTime?
  failedAt      DateTime?
  errorMessage  String?
  bookingId     String?
  paymentId     String?
  sessionId     String?
  createdAt     DateTime @default(now())

  toUser        User?        @relation(fields: [toUserId], references: [id], onDelete: SetNull)
  booking       Booking?     @relation(fields: [bookingId], references: [id], onDelete: SetNull)
  payment       Payment?     @relation(fields: [paymentId], references: [id], onDelete: SetNull)
  session       Session?     @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([toUserId, createdAt])
  @@index([type, createdAt])
}

model AuditLog {
  id          String   @id @default(cuid())
  actorUserId String?
  entityType  String
  entityId    String
  action      String
  metadata    Json?
  createdAt   DateTime @default(now())

  actor       User? @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId, createdAt])
}

/// =====================
/// RLS guidance (comments)
/// - Public: read only published ExpertProfile fields and derived open slots (via view/RPC).
/// - Learners: read/write own Bookings; read own Payment (masked); read own Session participant URL.
/// - Experts: read/write own ExpertProfile & AvailabilitySlot; read Bookings for their ExpertProfile; read Session host URL.
/// - Admin/system only: mutate Payment state; insert AuditLog.
/// =====================